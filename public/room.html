<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Jim-jam Room üéµ</title>

  <!-- CSS Files -->
  <link rel="stylesheet" href="/styles/variables.css">
  <link rel="stylesheet" href="/styles/reset.css">
  <link rel="stylesheet" href="/styles/base.css">
  <link rel="stylesheet" href="/styles/components.css">
  <link rel="stylesheet" href="/styles/room.css">
  <link rel="stylesheet" href="/styles/responsive.css">
</head>
<body>
  <!-- Name Modal -->
  <div class="modal" id="nameModal">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title">üéµ Join the Jam</h2>
        <p class="modal-description">What should we call you?</p>
      </div>
      <input
        type="text"
        id="userName"
        class="input"
        placeholder="Your name"
        maxlength="20"
        autofocus
      >
      <div class="modal-footer">
        <button class="btn btn-primary" onclick="joinRoom()">Join Room</button>
      </div>
    </div>
  </div>

  <!-- Audio Enable Prompt -->
  <div class="audio-prompt" id="audioPrompt" onclick="forceEnableAudio()">
    üîä Click here to enable audio
  </div>

  <!-- Toast Notification -->
  <div class="toast" id="toast">
    <span class="toast-icon" id="toastIcon">‚ÑπÔ∏è</span>
    <div class="toast-content" id="toastMessage"></div>
    <button class="toast-close" onclick="closeToast()">‚úï</button>
  </div>

  <!-- Header -->
  <header class="room-header">
    <div class="room-header-container">
      <a href="/" class="room-logo">
        <span>üéµ</span>
        <span>Jim-jam</span>
      </a>

      <div class="room-info">
        <span class="room-code-display">
          Room: <strong id="roomCodeDisplay"></strong>
        </span>
        <button class="btn btn-secondary" style="padding: 8px 16px; font-size: 14px;" onclick="copyRoomLink()">
          Copy Link
        </button>
        <a href="/" class="btn btn-ghost" style="padding: 8px 16px; font-size: 14px;">
          Leave
        </a>
      </div>
    </div>
  </header>

  <!-- Main Content -->
  <main class="room-content">
    <!-- Player Section -->
    <section class="player-section">
      <!-- Music Player -->
      <div class="music-player">
        <div class="album-art-container" id="albumArtContainer">
          <div class="no-music" id="noMusic">
            <div class="no-music-icon">üéµ</div>
            <p class="no-music-text">Search for a song to start jamming!</p>
          </div>
          <img class="album-art" id="albumArt" src="" alt="Album Art">
        </div>

        <!-- Hidden YouTube Player -->
        <div id="hiddenPlayer">
          <div id="player"></div>
        </div>

        <div class="track-info" id="trackInfo" style="display: none;">
          <div class="track-title" id="trackTitle">Song Title</div>
          <div class="track-artist" id="trackArtist">Artist Name</div>
        </div>

        <div class="player-progress" id="playerProgress" style="display: none;">
          <div class="progress interactive" id="progressBar">
            <div class="progress-bar" id="progressFill" style="width: 0%"></div>
            <div class="progress-handle" id="progressHandle" style="left: 0%"></div>
          </div>
          <div class="progress-time">
            <span id="currentTime">0:00</span>
            <span id="duration">0:00</span>
          </div>
        </div>

        <div class="player-controls" id="playerControls" style="display: none;">
          <button class="btn-icon" onclick="skipBack()" title="Back 10s">
            ‚è™
          </button>
          <button class="btn-icon large" onclick="togglePlay()" id="playPauseBtn">
            ‚ñ∂Ô∏è
          </button>
          <button class="btn-icon" onclick="playNext()" title="Next">
            ‚è≠Ô∏è
          </button>
        </div>
      </div>

      <!-- Search Section -->
      <div class="search-container">
        <div class="search-input-wrapper">
          <input
            type="text"
            id="searchInput"
            class="input input-search"
            placeholder="Search as you type..."
          >
          <button class="btn btn-primary" onclick="if (searchTimeout) clearTimeout(searchTimeout); searchYouTube();">Search</button>
        </div>

        <div class="search-results" id="searchResults"></div>
      </div>
    </section>

    <!-- Sidebar -->
    <aside class="sidebar">
      <!-- Users Panel -->
      <div class="sidebar-panel users-panel">
        <div class="sidebar-header">
          <h3 class="sidebar-title">
            <span>üë•</span>
            <span>Listeners</span>
          </h3>
          <span class="sidebar-count" id="userCount">0</span>
        </div>
        <div class="sidebar-content">
          <div id="usersList"></div>
        </div>
      </div>

      <!-- Queue Panel -->
      <div class="sidebar-panel queue-panel">
        <div class="sidebar-header">
          <h3 class="sidebar-title">
            <span>üìù</span>
            <span>Queue</span>
          </h3>
        </div>
        <div class="sidebar-content" id="queueList">
          <div class="queue-empty">Queue is empty</div>
        </div>
      </div>

      <!-- Chat Panel -->
      <div class="sidebar-panel chat-panel">
        <div class="sidebar-header">
          <h3 class="sidebar-title">
            <span>üí¨</span>
            <span>Chat</span>
          </h3>
        </div>
        <div class="chat-messages" id="chatMessages"></div>
        <div class="chat-input-wrapper">
          <input
            type="text"
            id="chatInput"
            class="input"
            placeholder="Say something..."
          >
          <button class="btn btn-primary" onclick="sendChat()" style="padding: 12px 24px;">
            Send
          </button>
        </div>
      </div>
    </aside>
  </main>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const roomId = window.location.pathname.split('/').pop();
    document.getElementById('roomCodeDisplay').textContent = roomId;

    let socket;
    let player;
    let isHost = false;
    let isSyncing = false;
    let syncInterval = null;
    let userName = '';
    let wasPlayingBeforeHidden = false;
    let lastKnownTime = 0;
    let wakeLock = null;

    // Wake Lock API - Keep screen awake during playback (mobile)
    async function requestWakeLock() {
      try {
        if ('wakeLock' in navigator) {
          wakeLock = await navigator.wakeLock.request('screen');
          console.log('Wake Lock acquired - screen will stay on');

          wakeLock.addEventListener('release', () => {
            console.log('Wake Lock released');
          });
        }
      } catch (err) {
        // Wake Lock not supported or denied - that's okay
        console.log('Wake Lock not available:', err.message);
      }
    }

    function releaseWakeLock() {
      if (wakeLock) {
        wakeLock.release();
        wakeLock = null;
      }
    }

    // Page Visibility API - Handle mobile background/foreground
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        // User switched away - remember if we were playing
        if (player && player.getPlayerState) {
          wasPlayingBeforeHidden = player.getPlayerState() === YT.PlayerState.PLAYING;
          lastKnownTime = player.getCurrentTime();
        }
        // Release wake lock when hidden
        releaseWakeLock();
      } else {
        // User returned - resync immediately
        if (socket && socket.connected && player) {
          console.log('User returned to tab - requesting sync');

          // Force immediate sync request
          socket.emit('sync-request');

          // Show notification
          showToast('info', 'Syncing playback...');

          // If was playing, try to resume
          if (wasPlayingBeforeHidden) {
            setTimeout(() => {
              if (player && player.getPlayerState() !== YT.PlayerState.PLAYING) {
                player.playVideo();
              }
              // Re-acquire wake lock if playing
              requestWakeLock();
            }, 500);
          }

          // Do extra sync checks for the next 10 seconds to ensure good sync
          let extraSyncCount = 0;
          const extraSyncInterval = setInterval(() => {
            if (extraSyncCount >= 5 || !socket || !socket.connected) {
              clearInterval(extraSyncInterval);
              return;
            }
            socket.emit('sync-request');
            extraSyncCount++;
          }, 2000); // Every 2 seconds for 10 seconds
        }
      }
    });

    // YouTube IFrame API
    const tag = document.createElement('script');
    tag.src = 'https://www.youtube.com/iframe_api';
    const firstScript = document.getElementsByTagName('script')[0];
    firstScript.parentNode.insertBefore(tag, firstScript);

    let userInteracted = false;

    function onYouTubeIframeAPIReady() {
      player = new YT.Player('player', {
        height: '360',
        width: '640',
        playerVars: {
          autoplay: 1,
          controls: 0,
          rel: 0,
          modestbranding: 1,
          playsinline: 1,
          enablejsapi: 1,
          origin: window.location.origin
        },
        events: {
          onReady: onPlayerReady,
          onStateChange: onPlayerStateChange,
          onError: onPlayerError
        }
      });
    }

    function onPlayerReady(event) {
      console.log('Player ready');
      player.setVolume(100);
      player.unMute();
    }

    function onPlayerError(event) {
      console.error('YouTube Player Error:', event.data);
      let errorMessage = 'Video playback error. ';

      switch (event.data) {
        case 2:
          errorMessage += 'Invalid video ID.';
          break;
        case 5:
          errorMessage += 'HTML5 player error.';
          break;
        case 100:
          errorMessage += 'Video not found.';
          break;
        case 101:
        case 150:
          errorMessage += 'Embedding disabled for this video.';
          break;
        default:
          errorMessage += 'Unknown error.';
      }

      showToast('error', errorMessage + ' Skipping to next...');
      addSystemMessage(errorMessage + ' Skipping...');
      socket.emit('play-next');
    }

    function enableAudio() {
      if (!userInteracted && player) {
        userInteracted = true;
        player.unMute();
        player.setVolume(100);
        document.getElementById('audioPrompt').classList.remove('show');
        if (player.getVideoData && player.getVideoData().video_id) {
          player.playVideo();
        }
      }
    }

    function forceEnableAudio() {
      enableAudio();
      if (player && player.getPlayerState() !== YT.PlayerState.PLAYING) {
        player.playVideo();
      }
    }

    function checkAudioPrompt() {
      if (!userInteracted && player && player.isMuted && player.isMuted()) {
        document.getElementById('audioPrompt').classList.add('show');
      }
    }

    document.addEventListener('click', enableAudio, { once: false });
    document.addEventListener('keydown', enableAudio, { once: false });

    function onPlayerStateChange(event) {
      if (isSyncing) return;

      if (event.data === YT.PlayerState.PLAYING) {
        updatePlayingState(true);
        socket.emit('toggle-play', {
          isPlaying: true,
          currentTime: player.getCurrentTime()
        });
      } else if (event.data === YT.PlayerState.PAUSED) {
        updatePlayingState(false);
        socket.emit('toggle-play', {
          isPlaying: false,
          currentTime: player.getCurrentTime()
        });
      } else if (event.data === YT.PlayerState.ENDED) {
        updatePlayingState(false);
        socket.emit('play-next');
      }
    }

    function joinRoom() {
      userName = document.getElementById('userName').value.trim() || 'Anonymous';
      document.getElementById('nameModal').classList.add('hidden');

      socket = io();

      socket.on('connect', () => {
        socket.emit('join-room', { roomId, name: userName });
      });

      socket.on('room-state', (state) => {
        isHost = state.isHost;
        updateUsers(state.users);
        updateQueue(state.queue);

        if (state.currentVideo) {
          loadVideo(state.currentVideo.id, state.currentTime, state.isPlaying);
          showNowPlaying(state.currentVideo.title, state.currentVideo.thumbnail, state.currentVideo.artist);
          if (state.isPlaying) updatePlayingState(true);
        }
      });

      socket.on('video-changed', (data) => {
        loadVideo(data.id, data.currentTime, data.isPlaying);
        showNowPlaying(data.title, data.thumbnail, data.artist);
        if (data.isPlaying) updatePlayingState(true);
      });

      socket.on('play-state-changed', (data) => {
        isSyncing = true;
        updatePlayingState(data.isPlaying);
        if (data.isPlaying) {
          player.seekTo(data.currentTime, true);
          player.playVideo();
        } else {
          player.pauseVideo();
          player.seekTo(data.currentTime, true);
        }
        setTimeout(() => isSyncing = false, 500);
      });

      socket.on('seeked', (data) => {
        isSyncing = true;
        player.seekTo(data.currentTime, true);
        setTimeout(() => isSyncing = false, 500);
      });

      socket.on('sync-response', (data) => {
        if (!player || !player.getCurrentTime) return;

        const currentTime = player.getCurrentTime();
        const diff = Math.abs(currentTime - data.currentTime);

        // More aggressive sync (1 second threshold instead of 2)
        if (diff > 1) {
          console.log(`Out of sync by ${diff.toFixed(2)}s - resyncing to ${data.currentTime.toFixed(2)}`);

          isSyncing = true;
          player.seekTo(data.currentTime, true);

          // Resume playback if server says we should be playing
          if (data.isPlaying && player.getPlayerState() !== YT.PlayerState.PLAYING) {
            player.playVideo();
          } else if (!data.isPlaying && player.getPlayerState() === YT.PlayerState.PLAYING) {
            player.pauseVideo();
          }

          setTimeout(() => isSyncing = false, 500);

          // Show notification only if significantly out of sync (> 3 seconds)
          if (diff > 3) {
            showToast('success', `Synced to ${formatTime(data.currentTime)}`);
          }
        }
      });

      socket.on('user-joined', (user) => {
        addSystemMessage(`${user.name} joined the jam`);
      });

      socket.on('user-left', (user) => {
        addSystemMessage(`${user.name} left`);
      });

      socket.on('queue-updated', (data) => {
        updateQueue(data.queue);
      });

      socket.on('chat-message', (data) => {
        addChatMessage(data.user, data.message);
      });

      socket.on('became-host', () => {
        isHost = true;
        addSystemMessage('You are now the host');
      });

      socket.on('error', (data) => {
        showToast('error', data.message);
        setTimeout(() => {
          window.location.href = '/';
        }, 2000);
      });

      socket.on('connect_error', (error) => {
        console.error('Connection error:', error);
        showToast('error', 'Connection error. Retrying...');
      });

      socket.on('disconnect', (reason) => {
        console.log('Disconnected:', reason);

        if (syncInterval) {
          clearInterval(syncInterval);
          syncInterval = null;
        }

        if (player && player.getPlayerState && player.getPlayerState() === YT.PlayerState.PLAYING) {
          player.pauseVideo();
        }

        if (reason === 'io server disconnect') {
          showToast('error', 'Disconnected from server. Reconnecting...');
          socket.connect();
        } else if (reason === 'transport close' || reason === 'transport error') {
          showToast('error', 'Lost connection. Reconnecting...');
        }
      });

      socket.on('reconnect', (attemptNumber) => {
        console.log('Reconnected after', attemptNumber, 'attempts');
        showToast('success', '‚úì Reconnected successfully!');

        if (!syncInterval) {
          syncInterval = setInterval(() => {
            if (player && player.getPlayerState && player.getPlayerState() === YT.PlayerState.PLAYING) {
              socket.emit('sync-request');
            }
          }, 5000);
        }

        socket.emit('join-room', { roomId, name: userName });
      });

      socket.on('reconnect_error', (error) => {
        console.error('Reconnection error:', error);
      });

      socket.on('reconnect_failed', () => {
        showToast('error', 'Failed to reconnect. Please refresh the page.');
      });

      socket.on('inactivity-warning', (data) => {
        showToast('warning', '‚ö†Ô∏è ' + data.message);
        addSystemMessage(data.message);
      });

      socket.on('room-closed', (data) => {
        showToast('error', data.message);
        addSystemMessage(data.message);
        setTimeout(() => {
          window.location.href = '/';
        }, 3000);
      });

      syncInterval = setInterval(() => {
        if (player && player.getPlayerState && player.getPlayerState() === YT.PlayerState.PLAYING) {
          socket.emit('sync-request');
        }
      }, 5000);
    }

    function cleanup() {
      if (syncInterval) {
        clearInterval(syncInterval);
        syncInterval = null;
      }

      if (player && player.getPlayerState && player.getPlayerState() === YT.PlayerState.PLAYING) {
        player.pauseVideo();
      }

      if (socket && socket.connected) {
        socket.disconnect();
      }
    }

    window.addEventListener('beforeunload', cleanup);

    function loadVideo(videoId, startTime, autoplay) {
      document.getElementById('noMusic').style.display = 'none';
      isSyncing = true;

      if (player.unMute) player.unMute();
      if (player.setVolume) player.setVolume(100);

      if (autoplay) {
        player.loadVideoById(videoId, startTime);
      } else {
        player.cueVideoById(videoId, startTime);
      }

      setTimeout(() => {
        isSyncing = false;
        if (!userInteracted && player.isMuted && player.isMuted()) {
          document.getElementById('audioPrompt').classList.add('show');
        }
      }, 1000);
    }

    function showNowPlaying(title, thumbnail, artist) {
      document.getElementById('noMusic').style.display = 'none';
      document.getElementById('trackInfo').style.display = 'block';
      document.getElementById('playerControls').style.display = 'flex';
      document.getElementById('playerProgress').style.display = 'block';
      document.getElementById('trackTitle').textContent = title;
      document.getElementById('trackArtist').textContent = artist || 'Unknown Artist';

      const albumArt = document.getElementById('albumArt');
      albumArt.src = thumbnail;
      albumArt.onerror = () => { albumArt.src = 'https://via.placeholder.com/300?text=No+Art'; };
      albumArt.classList.add('active');
    }

    function togglePlay() {
      if (player.getPlayerState() === YT.PlayerState.PLAYING) {
        player.pauseVideo();
      } else {
        player.playVideo();
      }
    }

    function skipBack() {
      const currentTime = player.getCurrentTime();
      const newTime = Math.max(0, currentTime - 10);
      player.seekTo(newTime, true);
      socket.emit('seek', { currentTime: newTime });
    }

    function playNext() {
      socket.emit('play-next');
    }

    function updatePlayingState(isPlaying) {
      const container = document.getElementById('albumArtContainer');
      const playPauseBtn = document.getElementById('playPauseBtn');

      if (isPlaying) {
        container.classList.add('playing');
        if (playPauseBtn) playPauseBtn.textContent = '‚è∏Ô∏è';
      } else {
        container.classList.remove('playing');
        if (playPauseBtn) playPauseBtn.textContent = '‚ñ∂Ô∏è';
      }
    }

    function updateUsers(users) {
      const list = document.getElementById('usersList');
      document.getElementById('userCount').textContent = users.length;

      list.innerHTML = users.map((user, i) => `
        <div class="user-item">
          <div class="avatar">${user.name[0].toUpperCase()}</div>
          <span class="user-name">${user.name}</span>
          ${i === 0 ? '<span class="host-badge">HOST</span>' : ''}
        </div>
      `).join('');
    }

    // ===== DRAG AND DROP QUEUE REORDERING =====

    let draggedItem = null;
    let draggedIndex = null;

    function updateQueue(queue) {
      const list = document.getElementById('queueList');
      if (queue.length === 0) {
        list.innerHTML = '<div class="queue-empty">Queue is empty</div>';
      } else {
        list.innerHTML = queue.map((item, i) => `
          <div
            class="queue-item ${i === 0 ? 'current' : ''}"
            draggable="${i > 0}"
            data-index="${i}"
          >
            ${i > 0 ? '<div class="queue-drag-handle">‚ãÆ‚ãÆ</div>' : ''}
            <div class="queue-item-info">
              <div class="queue-item-title">${escapeHtml(item.title)}</div>
              <div class="queue-item-added-by">Added by ${item.addedBy}</div>
            </div>
          </div>
        `).join('');

        // Add drag and drop event listeners
        setupQueueDragAndDrop();
      }
    }

    function setupQueueDragAndDrop() {
      const queueItems = document.querySelectorAll('.queue-item[draggable="true"]');

      queueItems.forEach((item) => {
        item.addEventListener('dragstart', handleDragStart);
        item.addEventListener('dragend', handleDragEnd);
        item.addEventListener('dragover', handleDragOver);
        item.addEventListener('drop', handleDrop);
        item.addEventListener('dragenter', handleDragEnter);
        item.addEventListener('dragleave', handleDragLeave);
      });
    }

    function handleDragStart(e) {
      draggedItem = e.currentTarget;
      draggedIndex = parseInt(draggedItem.dataset.index);
      draggedItem.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/html', draggedItem.innerHTML);
    }

    function handleDragEnd(e) {
      e.currentTarget.classList.remove('dragging');
      // Remove all drag-over classes
      document.querySelectorAll('.queue-item').forEach(item => {
        item.classList.remove('drag-over');
      });
    }

    function handleDragOver(e) {
      if (e.preventDefault) {
        e.preventDefault();
      }
      e.dataTransfer.dropEffect = 'move';
      return false;
    }

    function handleDragEnter(e) {
      if (e.currentTarget !== draggedItem) {
        e.currentTarget.classList.add('drag-over');
      }
    }

    function handleDragLeave(e) {
      e.currentTarget.classList.remove('drag-over');
    }

    function handleDrop(e) {
      if (e.stopPropagation) {
        e.stopPropagation();
      }

      e.currentTarget.classList.remove('drag-over');

      if (draggedItem !== e.currentTarget) {
        const dropIndex = parseInt(e.currentTarget.dataset.index);

        // Emit reorder event to server
        socket.emit('reorder-queue', {
          fromIndex: draggedIndex,
          toIndex: dropIndex
        });
      }

      return false;
    }

    function addChatMessage(user, message) {
      const container = document.getElementById('chatMessages');
      const div = document.createElement('div');
      div.className = 'chat-message';
      div.innerHTML = `
        <div class="chat-user">${user}</div>
        <div class="chat-text">${escapeHtml(message)}</div>
      `;
      container.appendChild(div);
      container.scrollTop = container.scrollHeight;
    }

    function addSystemMessage(message) {
      const container = document.getElementById('chatMessages');
      const div = document.createElement('div');
      div.className = 'chat-message system';
      div.innerHTML = `<div class="chat-text">${message}</div>`;
      container.appendChild(div);
      container.scrollTop = container.scrollHeight;
    }

    function sendChat() {
      const input = document.getElementById('chatInput');
      const message = input.value.trim();
      if (message) {
        socket.emit('chat-message', { message });
        input.value = '';
      }
    }

    document.getElementById('chatInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') sendChat();
    });

    // ===== LIVE SEARCH WITH DEBOUNCING =====

    let searchTimeout = null;
    let isSearching = false;

    async function searchYouTube(query = null) {
      const searchQuery = query || document.getElementById('searchInput').value.trim();
      const container = document.getElementById('searchResults');

      // Clear results if query is empty
      if (!searchQuery) {
        container.classList.remove('active');
        container.innerHTML = '';
        return;
      }

      // Show loading state
      isSearching = true;
      container.classList.add('active');
      container.innerHTML = `
        <div style="padding: 2rem; text-align: center; color: var(--text-muted);">
          <div class="spinner" style="margin: 0 auto 1rem;"></div>
          <p>Searching YouTube...</p>
        </div>
      `;

      try {
        const res = await fetch(`/api/search?q=${encodeURIComponent(searchQuery)}`);
        const results = await res.json();

        if (results.error) {
          container.innerHTML = `
            <div style="padding: 2rem; text-align: center; color: var(--text-muted);">
              <p>‚ùå Search failed: ${results.error}</p>
            </div>
          `;
          showToast('error', 'Search failed: ' + results.error);
          return;
        }

        if (results.length === 0) {
          container.innerHTML = `
            <div style="padding: 2rem; text-align: center; color: var(--text-muted);">
              <p>üîç No results found for "${escapeHtml(searchQuery)}"</p>
              <p style="font-size: var(--text-sm); margin-top: 0.5rem;">Try a different search term</p>
            </div>
          `;
          return;
        }

        container.innerHTML = results.map(result => `
          <div class="search-result" onclick="playVideo('${result.id}', '${escapeHtml(result.title).replace(/'/g, "\\'")}', '${result.thumbnail}', '${escapeHtml(result.artist).replace(/'/g, "\\'")}', '${result.source}')">
            <img class="search-result-thumbnail" src="${result.thumbnail}" alt="">
            <div class="search-result-info">
              <div class="search-result-title">${escapeHtml(result.title)}</div>
              <div class="search-result-artist">${escapeHtml(result.artist)} ${result.duration ? '‚Ä¢ ' + result.duration : ''}</div>
            </div>
            <div class="search-result-actions">
              <button class="btn btn-primary search-result-btn" onclick="event.stopPropagation(); playVideo('${result.id}', '${escapeHtml(result.title).replace(/'/g, "\\'")}', '${result.thumbnail}', '${escapeHtml(result.artist).replace(/'/g, "\\'")}', '${result.source}')">‚ñ∂ Play</button>
              <button class="btn btn-secondary search-result-btn" onclick="event.stopPropagation(); addToQueue('${result.id}', '${escapeHtml(result.title).replace(/'/g, "\\'")}', '${result.thumbnail}', '${escapeHtml(result.artist).replace(/'/g, "\\'")}', '${result.source}')">+ Queue</button>
            </div>
          </div>
        `).join('');
      } catch (err) {
        console.error('Search failed:', err);
        container.innerHTML = `
          <div style="padding: 2rem; text-align: center; color: var(--text-muted);">
            <p>‚ùå Connection error. Please try again.</p>
          </div>
        `;
        showToast('error', 'Search failed. Please check your connection and try again.');
      } finally {
        isSearching = false;
      }
    }

    // Debounced live search
    function handleSearchInput() {
      const query = document.getElementById('searchInput').value.trim();

      // Clear existing timeout
      if (searchTimeout) {
        clearTimeout(searchTimeout);
      }

      // If empty, clear results immediately
      if (!query) {
        searchYouTube('');
        return;
      }

      // Wait 500ms after user stops typing before searching
      searchTimeout = setTimeout(() => {
        searchYouTube(query);
      }, 500);
    }

    // Setup live search on input
    document.addEventListener('DOMContentLoaded', () => {
      const searchInput = document.getElementById('searchInput');
      if (searchInput) {
        searchInput.addEventListener('input', handleSearchInput);
        searchInput.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            // Clear timeout and search immediately on Enter
            if (searchTimeout) clearTimeout(searchTimeout);
            searchYouTube();
          }
        });
      }
    });

    function playVideo(id, title, thumbnail, artist, source) {
      socket.emit('play-video', { id, title, thumbnail, artist, source });
      document.getElementById('searchResults').classList.remove('active');
      document.getElementById('searchInput').value = '';
    }

    function addToQueue(id, title, thumbnail, artist, source) {
      socket.emit('add-to-queue', { id, title, thumbnail, artist, source });
      showToast('success', 'Added to queue!');
    }

    function copyRoomLink() {
      navigator.clipboard.writeText(window.location.href).then(() => {
        showToast('success', '‚úì Room link copied to clipboard!');
      }).catch(() => {
        showToast('error', 'Failed to copy link. Please copy manually.');
      });
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function showToast(type, message) {
      const toast = document.getElementById('toast');
      const icon = document.getElementById('toastIcon');
      const messageEl = document.getElementById('toastMessage');

      const icons = {
        success: '‚úì',
        error: '‚ö†Ô∏è',
        warning: '‚ö†Ô∏è',
        info: '‚ÑπÔ∏è'
      };

      icon.textContent = icons[type] || icons.info;
      messageEl.textContent = message;

      toast.classList.remove('success', 'error', 'warning', 'info');
      toast.classList.add(type, 'show');

      setTimeout(() => {
        closeToast();
      }, 5000);
    }

    function closeToast() {
      document.getElementById('toast').classList.remove('show');
    }

    // ===== INTERACTIVE PROGRESS BAR =====

    let progressUpdateInterval = null;

    // Format seconds to MM:SS
    function formatTime(seconds) {
      if (!seconds || isNaN(seconds)) return '0:00';
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    // Update progress bar in real-time
    function updateProgress() {
      if (!player || !player.getDuration || !player.getCurrentTime) return;

      const duration = player.getDuration();
      const currentTime = player.getCurrentTime();

      if (duration > 0) {
        const progress = (currentTime / duration) * 100;
        const progressFill = document.getElementById('progressFill');
        const progressHandle = document.getElementById('progressHandle');
        const currentTimeEl = document.getElementById('currentTime');
        const durationEl = document.getElementById('duration');

        if (progressFill) progressFill.style.width = `${progress}%`;
        if (progressHandle) progressHandle.style.left = `${progress}%`;
        if (currentTimeEl) currentTimeEl.textContent = formatTime(currentTime);
        if (durationEl) durationEl.textContent = formatTime(duration);
      }
    }

    // Start/stop progress updates
    function startProgressUpdates() {
      if (progressUpdateInterval) clearInterval(progressUpdateInterval);
      progressUpdateInterval = setInterval(updateProgress, 100); // Update 10 times per second
    }

    function stopProgressUpdates() {
      if (progressUpdateInterval) {
        clearInterval(progressUpdateInterval);
        progressUpdateInterval = null;
      }
    }

    // Click to seek on progress bar
    document.addEventListener('DOMContentLoaded', () => {
      const progressBar = document.getElementById('progressBar');

      if (progressBar) {
        progressBar.addEventListener('click', (e) => {
          if (!player || !player.getDuration) return;

          const rect = progressBar.getBoundingClientRect();
          const clickX = e.clientX - rect.left;
          const width = rect.width;
          const percentage = clickX / width;
          const duration = player.getDuration();
          const seekTime = duration * percentage;

          // Seek to position
          player.seekTo(seekTime, true);
          socket.emit('seek', { currentTime: seekTime });

          // Immediately update UI
          updateProgress();
        });
      }
    });

    // Update showNowPlaying to start progress updates
    const originalShowNowPlaying = showNowPlaying;
    showNowPlaying = function(title, thumbnail, artist) {
      originalShowNowPlaying(title, thumbnail, artist);
      startProgressUpdates();
    };

    // Update updatePlayingState to handle progress updates and wake lock
    const originalUpdatePlayingState = updatePlayingState;
    updatePlayingState = function(isPlaying) {
      originalUpdatePlayingState(isPlaying);
      if (isPlaying) {
        startProgressUpdates();
        requestWakeLock(); // Keep screen on during playback
      } else {
        stopProgressUpdates();
        updateProgress(); // One final update when paused
        releaseWakeLock(); // Allow screen to sleep when paused
      }
    };

    // Cleanup progress interval and wake lock on page unload
    const originalCleanup = cleanup;
    cleanup = function() {
      stopProgressUpdates();
      releaseWakeLock();
      originalCleanup();
    };

    document.getElementById('userName').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') joinRoom();
    });
  </script>
</body>
</html>
